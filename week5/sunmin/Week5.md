# [GDSC_PS study] 5주차 스터디 회고

> 팀원들이 사람인 카페가 좋다던데.. 다음에는 꼭 사람인 카페에 가서 대면 회의를 해볼 수 있길!
> 
> 기대된다. :)


## 백준 9655번
**처음 내가 쓴 코드**
> 상근이가 이기는 경우를 2가지로 나눠서 생각함
> 1. dp[i-1] == 1 : 이전 턴에서 1개를 가져가는 경우
> 2. dp[i-3] == 1 : 이전 턴에서 3개를 가져가는 경우
>
> 이전 턴에 1개를 가져가든, 3개를 가져가든 n이 홀수면 이전 턴에서 상근이가 마지막껄 가져간거니까 상근이가 이기는거고, n이 짝수면 창영이가 마지막껄 가져간거니까 창영이가 이기는 거임
```
import sys
input = sys.stdin.readline

n = int(input()) # 돌 개수

# dp = [0 for i in range(N)]
# dp = [0] * N
dp = [0] * 1001

# dp[i-3]을 연산하기 위해서 dp[1]~dp[3]까지 값을 미리 지정함
dp[1] = 1 # SK
dp[2] = 0 # CY
dp[3] = 1 # SK

# 홀수면, 상근이가 이김 = SK
# 짝수면, 창영이가 이김 = CY
for i in range(4, n+1): 
    # 처음에 n으로 했을때, indexerror 났음
    # indexerror 난 이유 : N = 1001로 설정했는데, n은 1000까지이므로 n이 N의 index 범위를 넘어가서 error가 발생했음
    # 그래서 범위를 n+1로 고쳐야했음!\
    
    if dp[i-1] == 1 or dp[i-3] == 1: # 상근이가 이기는 경우 (SK)
        dp[i] = 0
    
    else:
        dp[i] = 1 # 창영이가 이기는 경우 (CY)

if dp[n] == 1: # 상근이가 이기는 경우
    print("SK")

else: # 0창영이가 이기는 경우
    print("CY") 
```

**팀원들의 조언을 받아 고쳐본 코드**
> 이전 턴에 얼마나 가져갔는지를 생각하지 않고 그냥 0, 1이 반복된다고 해도 코드가 맞았다.
> 
> (온라인 회의를 하면서 중간에 연결이 불안정해서 0, 1이 반복된다고 생각했냐는 말을 짝수, 홀수를 생각했냐는 말로 착각해서 맞다고 잘못 대답했어요.. 2가지의 경우로 나눠서 작성했었는데..ㅠㅠ)
> 
> 단순하게 생각할수록 맞는 문제였는데, 혼자 너무 깊게 생각하다가 코드를 비효율적으로 쓴 것 같다. ;(
```
import sys
input = sys.stdin.readline

n = int(input()) # 돌 개수

# dp = [0 for i in range(N)]
# dp = [0] * N
dp = [0] * 1001

# dp[i-3]을 연산하기 위해서 dp[1]~dp[3]까지 값을 미리 지정함
dp[1] = 1 # SK
dp[2] = 0 # CY
dp[3] = 1 # SK

# 홀수면, 상근이가 이김 = SK
# 짝수면, 창영이가 이김 = CY
for i in range(4, n+1): 
    if dp[i-1] == 1: # 상근이가 이기는 경우 (SK)
        # dp[i-3] == 1의 경우를 제외했음
        # 이래도 맞았음!
        
        dp[i] = 0
    
    else:
        dp[i] = 1 # 창영이가 이기는 경우 (CY)

if dp[n] == 1: # 상근이가 이기는 경우
    print("SK")

else: # 0창영이가 이기는 경우
    print("CY") 
```











