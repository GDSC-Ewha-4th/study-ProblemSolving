## 📌 1920
### 입력받은 값을 이진탐색으로 실시간으로 넘기면 입력과 출력에 혼돈이 올 수 있지 않나요?
```c++
cin >> m;
for(int i = 0; i < m; i++) {
	cin >> tmp;
	binarySearch(n, tmp);
}
```

네 실시간으로 입력과 출력을 하는 경우 가끔 입출력이 섞여서 나오기도 하는데요, 그래서 이를 방지하고자 입출력을 빠르게 해주는 아래 3줄을 추가하였습니다.

```c++
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```

</br></br>

### for문을 두 번 돌려서 배열 두 개에 입력값을 넣고 관리해서 쓰면 될텐데 왜 `tmp`을 넘겼나요?
```c++
cin >> m;
for(int i = 0; i < m; i++) {
	cin >> tmp;
	binarySearch(n, tmp);
}
```

메모리를 최대한 적게 쓰고, 코드도 최대한 간단하게 쓰고 싶어서 배열은 입력 값에 대한 배열만 선언해주었습니다.

</br></br></br>

## 📌 2467
### `left`와 `right`에 `long long` 자료형을 쓴 이유가 있나요?
```c++
long long left = 0;
long long right = n - 1;
```

이전에 풀었던 문제에서 시간 초과 오류가 많이 났었기 때문에 평소에 `int` 로 썼던 변수들을 다 `long long`으로 다 바꾸다보니 위 두 가지 변수에도 `long long` 을 적용하게 된 것 같습니다.

</br></br></br>

## 📌 2805
### tree 배열의 크기는 1000000인데, 1000001 크기로 선언하신 이유가 있을까요?
```c++
int tree[1000001];
```

동적으로 할당된 배열의 경우 일부 구현에서는 메모리 해제를 위해 배열의 끝에 null 바이트(null terminator)를 자동으로 추가할 수 있는데, 이 경우 배열의 마지막 요소는 null 값('\0')이 들어간다고 알고 있습니다. 혹시 모를 경우를 방지하기 위해 항상 문제의 시작에서 배열을 선언할 때는 하나 더 여유를 주고 크기를 할당하는 편입니다.
