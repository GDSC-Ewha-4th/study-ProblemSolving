# Topic 2. Binary search
## 1. BOJ 1920
알고리즘을 짤때 if 조건 내부에 여러개의 조건을 담지 않는 것이 보통이다.
BUT 이 경우 나는 이에 대해 예외적인? 코드를 작성함.

<ore>
<code>

	while (1) {
		xr = (xl + xu) / 2;
		if (arr[xr] == x || arr[xl]==x || arr[xu]==x)
			return 1;
		if (x < arr[xr]) {
			xu = xr - 1; 
		}
		else 
			xl = xr + 1 ; 

		if (xl >= xu)
			return 0;
	}

</code>
</pre>

이에 대해 팀원분이 arr[xl]==x 랑 arr[xu]==x 지워도 돌아가냐 물어봤음  
-> 틀림   
- 왜?  
일단 틀렸다는 말은 양끝이 정답인 경우를 걸러주지 못한다는 것. 위에 내용을 제거하고 코드를 머릿속으로 돌려보았다.
예를 들어 맨 왼쪽값이 3이고 얘가 정답이라고 생각해보면
xu는 계속해서 3을 향해 -1씩 다가가게됨. 자 이제 xu가 4가 된 다음 두번째 if문을 탄다. 그러면 xu는 3으로 바뀜. 그 순간 return 0으로 종료됨. -> 결국 xr이 (3+3)/2 로 첫번째의 조건문을 만족시키며 1을 반환하기 이전에 끝나버리기 때문에 문제적이고, 틀리게 되는 것이라고 볼 수 있음.   
-> 그러면 대안이 있을까? 생각해보았다.  
-> 아 마지막 조건문에서 등호를 빼면 되겠다 싶어서 해봤는데 성공!! 이게 훨씬 좋은 코드로 보임. 왜냐하면 애초에 bisection에서 제약하는 건 양끝 함숫값의 곱 >0인 경우인데 0인 경우도 걸러주는 것은 너무 예외적이라 다른 문제에 대해 일반화하기 어렵기때문.

	while (1) {
		xr = (xl + xu) / 2;
		if (arr[xr] == x)
			return 1;
		if (x < arr[xr]) {
			xu = xr - 1;  //이미 xu에 대해 비교를 위에서 진행한 상태이므로 -1을 해주어야 중복된 조건문 계산을 막을 수 있음.
		}
		else 
			xl = xr + 1 ; //위와 같은 원리.

		if (xl > xu)
			return 0;
	}

------------------------

## 3. BOJ 2467
스터디 이후에 
내가 최솟값을 최대한 크게 설정한 것은 좀 위험한 방식이라는 생각이 들어서 대안을 고민을 해봤고, 솔루션을 찾았음.


	int xl = 0, xu = size - 1;
	int xr = -1;
	int res_xl=xl, res_xu=xu;  ///////////////////////
	int min = abs(get_sum(arr, xl, xu)); ///////////////////////
res_xl과 xu도 초기화 시켜두고 들어가야 
오류 없이 진행가능했다.